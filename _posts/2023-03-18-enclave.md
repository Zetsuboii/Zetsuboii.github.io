---
title: Secure Enclave Experience
date: 2023-03-18
author: zet
categories: [React & React Native]
tags: [100 Days of Blogging, Enclave, React Native]
---

I'm committing myself to the 100 days of blogging by writing about the stuff I'm learning.
These blogs won't be as helpful as a tutorial, but they should give insight about available sources
and my learning experience.

We're in the middle of the Scaling Ethereum hackathon, where the main focus is the Account Abstraction,
the new cool toy everyone has been talking about.

AA gives us new ways to think about transactions and allows us to define new ways to make them.

**Here's our killer pitch**:

Ethereum accounts use Secp256k1 elliptic curve by default. If you want to use the network, you have to generate a
key pair on this curve and sign transactions with your private key. Your Ethereum address is derived from
the public key.

One bad aspect of Ethereum user experience is that you have to go through the hassle of generating a wallet
(most of the time with 12 mnemonic words) and generating the private key using the entropy of the wallet.

It would be really *cool*, if we had a way to sign transactions without this process.

Most of the time when you generate a private key, it is encrypted and stored in a machine (Or sometimes 
[it isn't](https://cointelegraph.com/news/myalgo-users-urged-to-withdraw-as-cause-of-9-2m-hack-remains-unknown)
because developers are generous enough to share their users funds with others). This process is mostly safe if
implemented right, but for the brief moment where these keys are generated; one could theoritically observe the memory
and find it somewhere lying in the RAM. [Secure Enclave](https://support.apple.com/guide/security/secure-enclave-sec59b0b31ff/web)
is a way to generate and store these private keys in a part separate from the main system. This way private keys
aren't exposed even for a moment.

While using Enclave, instead of generating private keys directly we ask hardware to generate them for us. These
keys can be accessed with a human-readable-tag, which gives user to sign, verify, encrypt and decrypt using the private
key (but not view it).

Although most of the use case of Secure Enclave is to encrypt data and decrypt it, using signing functions to sign
Ethereum transactions is **possible**\*.

## Enclave: The Hard Parts

Even though it is theoritically possible, there are a few caveats:

- Secure Enclave uses Secp256r1 curve, which is not natively supported by Ethereum. (Tezos and Flow supports it)
- Apple's Enclave is designed to be used with Swift and Ethereum libraries for Swift are pretty weak. Also I'm not
  accustomed with the language anyways.
- Secp256k1 signing functions returns `v`, `r`, and `s` where `r` and `s` are considered the **signature** and `v`
  is the **recid**, allowing us to retrieve private key with the signature and the message hash. `v` is a value between
  [27,30] and determined by the ephemeral randomness `k` used while signing. This is unfortunately not implemented
  in Secure Enclave's signing functions and it is not something we can inject from the outside.

Our solution solves these problems as follows

- We use Optimism's [OP Stack](https://stack.optimism.io/docs/build/getting-started/#) combined with
  [ERC4337](https://www.alchemy.com/blog/account-abstraction), which allows us to define Secp256r1 
  precompiles and make transactions where the passing criteria is verification of a signature on this curve
- We use React Native with Native Modules. This has a few disadvantages (no Expo, no library to sign messages with Enclave)
  but it is also the easiest option so far
- Instead of `ecrecover(hash, signature) -> address`, we implemented `ecverify(hash, signature, pubkey) -> valid` function.
  Storing the public key on the account contract allows us to only use hash and signature while interacting.

## Enclave: How?

In order to make this work let's go step by step:
1. Update eth client (op-geth in our case) to have `ecverify` precompile at 0xA address.
2. Clone generic ERC4337 account wallets and update its validate function to use `ecverify`.
3. Write a wrappers around Secure Enclave functions with Swift, and import it from the RN side
4. Clean the header bytes generated by Secure Enclave public key and pass it to the executing client
5. Hope everything works as expected and execute a transaction 

## Swift wrappers and unholy world of iOS development with Objective C

In order to make signing work we have a few native functions to know.

```swift
/// Creates an access object for the keychain
func SecAccessControlCreateWithFlags(
  _ allocator: CFAllocator?, // Default allocator is kCFAllocatorDefault
  _ protection: CFTypeRef,
  _ flags: SecAccessControlCreateFlags,
  _ error: UnsafeMutablePointer<Unmanaged<CFError>?>?
) -> SecAccessControl?

/// Creates the key pair
public func SecKeyCreateRandomKey(
  _ parameters: CFDictionary,
  _ error: UnsafeMutablePointer<Unmanaged<CFError>?>?
) -> SecKey?

/// Deletes the key pair
public func SecItemDelete(_ query: CFDictionary) -> OSStatus

/// Gets the key stub of the tag
func SecItemCopyMatching(
  _ query: CFDictionary,
  _ result: UnsafeMutablePointer<CFTypeRef?>?
) -> OSStatus

/// The signing algorithm we'll use for the Enclave
public static let ecdsaSignatureMessageX962SHA256: SecKeyAlgorithm

/// Checks if signing algorithm is supported
func SecKeyIsAlgorithmSupported(
  _ key: SecKey,
  _ operation: SecKeyOperationType,
  _ algorithm: SecKeyAlgorithm
) -> Bool

/// Creates the signature
SecKeyCreateSignature(
  _ key: SecKey,
  _ algorithm: SecKeyAlgorithm,
  _ dataToSign: CFData,
  _ error: UnsafeMutablePointer<Unmanaged<CFError>?>?
) -> CFData?

/// Gets the public key of the tag
func SecKeyCopyPublicKey(_ key: SecKey) -> SecKey?

/// Gets the hex representation of the public key
func SecKeyCopyExternalRepresentation(
  _ key: SecKey,
  _ error: UnsafeMutablePointer<Unmanaged<CFError>?>?
) -> CFData?
```

They are not 100% consistent to be frank, some of them require the error pointer, others just throw blatantly.
But compared with their usage with Objective-C, working with imperfect APIs with Swift is 100 times better than
writing any Objective-C. For comparison here is the signature function in ObjC:

```objc
RCT_EXPORT_METHOD(createSignature: (NSDictionary *)params resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    NSString *promptMessage = [RCTConvert NSString:params[@"promptMessage"]];
    NSString *payload = [RCTConvert NSString:params[@"payload"]];

    NSData *biometricKeyTag = [self getBiometricKeyTag];
    NSDictionary *query = @{
      (id)kSecClass: (id)kSecClassKey,
      (id)kSecAttrApplicationTag: biometricKeyTag,
      (id)kSecAttrKeyType: (id)kSecAttrKeyTypeEC,
      (id)kSecReturnRef: @YES,
      (id)kSecUseOperationPrompt: promptMessage
      };
    SecKeyRef privateKey;
    OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, (CFTypeRef *)&privateKey);

    // If key has been found
    if (status == errSecSuccess) {
      NSError *error;
      NSData *dataToSign = [payload dataUsingEncoding:NSUTF8StringEncoding];
      NSData *signature = CFBridgingRelease(
        SecKeyCreateSignature(
          privateKey,
          kSecKeyAlgorithmECDSASignatureMessageX962SHA256,
          (CFDataRef)dataToSign,
          (void *)&error
        )
      );

      // If signing is successful
      if (signature != nil) {
        
        // Return Base64 encoded signature
        NSString *signatureString = [signature base64EncodedStringWithOptions:0];
        NSDictionary *result = @{
          @"success": @(YES),
          @"signature": signatureString
        };
        resolve(result);
      } else if (error.code == errSecUserCanceled) {
        NSDictionary *result = @{
          @"success": @(NO),
          @"error": @"User cancellation"
        };
        resolve(result);
      } else {
        NSString *message = [NSString stringWithFormat:@"Signature error: %@", error];
        reject(@"signature_error", message, nil);
      }
    } else {
      NSString *message = [NSString stringWithFormat:@"Key not found: %@",[self keychainErrorToString:status]];
      reject(@"storage_error", message, nil);
    }
  });
}
```

And here it is in Swift:

```swift
private func sign(_ message: String, _ keyHandle: SecKey) throws -> String {
  let messageData = message.data(using: .utf8)! as CFData
  
  guard SecKeyIsAlgorithmSupported(
    keyHandle,
    .sign,
    EnclaveModule.algorithm
  ) else {
      throw EnclaveError.message("Algorithm not supported on this Device")
  }
  
  var error: Unmanaged<CFError>?
  
  let signedMessage = SecKeyCreateSignature(
    keyHandle,
    EnclaveModule.algorithm,
    messageData,
    &error
  )
  
  guard signedMessage != nil else {
      print(error!)
      throw EnclaveError.message("Can't sign message")
  }
  
  return (signedMessage! as Data).base64EncodedString()
}
```

Objective C looks like what programming is to someone who never used a computer. After mangling with it for a few days,
not learning it as I refuse to read anything related to the language, I get some stuff about how function calls work
but it is still unreadable to me, and I hope I won't ever get close to it again.

Once we have the Swift function, they are exported in a different header file. We can define the function in the header
ending with .h and implement a module ending with .m . Since the function is implemented in Swift and .h & .m are in Obj-C
we can skip some loops and only write the .m as follows:

```objc
#import <React/RCTBridgeModule.h>

@interface RCT_EXTERN_MODULE(EnclaveModule, NSObject)

RCT_EXTERN_METHOD(signMessage:(NSString)alias
  message:(NSString)message
  resolver:(RCTPromiseResolveBlock)resolve
  rejecter:(RCTPromiseRejectBlock)reject)

@end
```

Tagging the Swift function with `@objc(<fnSignature>)` is enough to bind to functions together.
When all's said and done, in order to call the React Native function we can write

```ts
import {NativeModules} from 'react-native'

async function signMessage(alias: string, message: string) -> Promise<string> {
  await NativeModules.EnclaveModule.signMessage(alias, string)
}
```

And it's easy like that! Only if there was enough documentation and I didn't need to read tons of ancient
iOS code to understand how any of this work.

---

Here's bunch of notes and my personal rant about enclaves. If you're here for a result 
[this Github repo](https://github.com/itublockchain/opclave-scaling2023/tree/main/frontend) should be helpful.

Anyways, have a nice one

